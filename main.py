import streamlit as st
import pandas as pd
import numpy as np

# --- Title ---
st.title("Traffic Monitoring Dashboard")

# --- Load CSV File ---
csv_file = "log.csv"  # Adjust to your actual CSV filename

try:
    # Read CSV file
    df = pd.read_csv(csv_file)

    # Clean columns
    df.columns = df.columns.str.strip()

    # Check expected columns
    expected_cols = ["NodeID", "VehicleCount", "AvgSpeed", "ParkingStatus", "CongestionLevel"]
    if not all(col in df.columns for col in expected_cols):
        st.error(f"CSV file is missing one or more expected columns: {expected_cols}")
    else:
        # Add a simple simulated timestamp if none exists for time series
        if 'Timestamp' not in df.columns:
            df['Timestamp'] = pd.date_range(start='2025-07-01', periods=len(df), freq='min')

        # --- Sidebar Filters ---
        st.sidebar.header("Filters")

        # Filter NodeID
        node_filter = st.sidebar.multiselect(
            "Select NodeID(s)",
            options=df["NodeID"].unique(),
            default=df["NodeID"].unique()
        )

        # Filter ParkingStatus
        parking_filter = st.sidebar.multiselect(
            "Select Parking Status",
            options=df["ParkingStatus"].unique(),
            default=df["ParkingStatus"].unique()
        )

        # Filter DataFrame based on filters
        filtered_df = df[
            (df["NodeID"].isin(node_filter)) &
            (df["ParkingStatus"].isin(parking_filter))
        ]

        # Sort option
        sort_col = st.sidebar.selectbox(
            "Sort by",
            options=["VehicleCount", "AvgSpeed"],
            index=0
        )
        sort_order = st.sidebar.radio("Sort order", options=["Descending", "Ascending"])
        ascending = sort_order == "Ascending"
        filtered_df = filtered_df.sort_values(by=sort_col, ascending=ascending)

        # --- 1. Data Table ---
        st.subheader("Filtered Traffic Data Table")
        st.dataframe(filtered_df.reset_index(drop=True))

        # --- 2. Bar Chart: VehicleCount per NodeID with congestion color ---
        st.subheader("Vehicle Count per Node with Congestion Level")

        # Aggregate VehicleCount per NodeID and congestion level
        bar_data = (
            filtered_df.groupby(["NodeID", "CongestionLevel"])["VehicleCount"]
            .sum()
            .reset_index()
        )

        # Map congestion level to colors
        congestion_color_map = {
            "Low": "green",
            "Medium": "yellow",
            "High": "red"
        }

        import altair as alt

        bar_chart = alt.Chart(bar_data).mark_bar().encode(
            x=alt.X("NodeID:N", title="Node ID"),
            y=alt.Y("VehicleCount:Q", title="Total Vehicle Count"),
            color=alt.Color("CongestionLevel:N",
                            scale=alt.Scale(domain=list(congestion_color_map.keys()),
                                            range=list(congestion_color_map.values())),
                            legend=alt.Legend(title="Congestion Level")),
            tooltip=["NodeID", "CongestionLevel", "VehicleCount"]
        ).properties(width=700)

        st.altair_chart(bar_chart, use_container_width=True)

        # --- 3. Line Chart: AvgSpeed over time per NodeID ---
        st.subheader("Average Speed Over Time")

        selected_node = st.selectbox("Select NodeID to visualize AvgSpeed over time", node_filter)

        line_data = filtered_df[filtered_df["NodeID"] == selected_node]

        if not line_data.empty:
            line_chart = alt.Chart(line_data).mark_line(point=True).encode(
                x=alt.X("Timestamp:T", title="Time"),
                y=alt.Y("AvgSpeed:Q", title="Average Speed (km/h)"),
                tooltip=["Timestamp", "AvgSpeed"]
            ).properties(width=700)
            st.altair_chart(line_chart, use_container_width=True)
        else:
            st.info(f"No data available for {selected_node}")

except FileNotFoundError:
    st.error(f"CSV file '{csv_file}' not found. Please place it in the project folder.")
except Exception as e:
    st.error(f"Error loading CSV: {e}")

# --- Footer ---
st.caption("Data loaded from log.csv generated by the ESP32 base station.")
